# 第二章 信息的表示和处理

## 2.1 信息存储

### 2.1.1 十六进制表示法

**二进制与十进制较十六进制的缺点**

* 一个字节包括8位
  在二进制表示法中，它的值域是$00000000_2\sim11111111_2$
  在十进制表示法中，它的值域是$0_{10}\sim255_{10}$

  这两种表示法对于描述==位模式==来说都不是很方便

  二进制法太冗长，而十进制表示法与位模式的相互转换很麻烦

- 替换的方法是，我们以16为基数来书写位模式(即16进制，简写为Hex)
  即使用数字'0'\~'9'，以及字符'A'\~'F'来表示16个可能的值

  在十六进制表示法中，一个字节的取值范围是$00_{16}\sim FF_{16}$

  | 十六进制数字 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
  | :----------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
  |   十进制值   |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
  |   二进制值   | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 |
  | 十六进制数字 |  8   |  9   |  A   |  B   |  C   |  D   |  E   |  F   |
  |   十进制值   |  8   |  9   |  10  |  11  |  12  |  13  |  14  |  15  |
  |   二进制值   | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |

  <!--关于位模式
    位模式不是用来表达'数'的概念的，如一串二进制数00111011，它可能是个'数'，也可能是个声音，也可能是个字母，也可能是图像，即它是一串'以二进制为形式的东西'   -->

**二进制、十进制、十六进制的转换**

* 若一个十进制数$x=2^n$,则其二进制表示为：$100...00(n个0)$，如8=2^3^=1000~2~
* 将n表示为$n=i+4j(0\leq i \leq 3)$,则x写成16进制数：$s$后接$j$个十六进制的0
  其中，$s=1(i=0),s=2(i=1),s=4(i=2),s=8(i=3)$

### 2.1.2 机器字长

**-概念-**
	1.每台计算机都有一个字长，指明整数和指针数据的标称大小；
	2.或者说，机器字长指计算机进行一次整数运算所能处理的二进制数据的位数
**-作用-**

​	1.机器字长反映了计算机的==运算精度==，即字长越长，数的表示范围越大，精度也越高
​	2.机器字长也影响着机器的==运算速度==：处理位数多的数据，字长短的机器需要经过多次运算
​	3.字长决定了==虚拟地址空间==的最大大小
​		**-**对于一个字长为n位的机器而言，虚拟地址的范围为$0\sim 2^n-1$,程序最多访问$2^n$字节
​		**-**例如，对于一个字长为32位的计算机，其虚拟地址空间为4000M字节(GB)

**-衡量单位-**

​	1.衡量单位为'位'或'字节',如32位的CPU，一次可以处理4个字节




### 2.1.3 数据大小

**各种C数据类型分配的字节数**

|        Signed        |    Unsigned    | 32-bit | 64-bit |
| :------------------: | :------------: | :----: | :----: |
|    [signed] char     | unsigned char  |   1    |   1    |
|    short(短整型)     | unsigned short |   2    |   2    |
|         int          |    unsigned    |   4    |   4    |
|     long(长整型)     | unsigned long  |   4    |   8    |
|       int32_t        |    uint32_t    |   4    |   4    |
|       int64_t        |    uint64_t    |   8    |   8    |
|        char *        |                |   4    |   8    |
| float(单精度浮点型)  |                |   4    |   4    |
| double(双精度浮点型) |                |   8    |   8    |

### 2.1.4 寻址和字节顺序

**-多字节对象的存储方式-**

​	对于跨越多字节的程序对象，我们必须建立两个规则：
​		①这个对象的地址是什么

​		②在存储器中如何对这些字节排序
​	在几乎所有的机器上，多字节对象都被存储为==连续的字节序列==
​	对象的地址为==所用字节序列中最小的地址==
​	EG:假设一个int型变量x的地址为$0x100$,那么，x的4字节将被存储在存储器的$0x100,0x101,0x102,0x103$位置

**-大端法与小端法**

​	假设上述x的值为$0x01234567$
​	==大端法：==(最高有效字节在最前) 	==小端法：==(最低有效字节在最前)
​	

|            | **0x100** | **0x101** | **0x102** | **0x103** |
| :--------: | :-------: | :-------: | :-------: | :-------: |
| **大端法** |    01     |    23     |    45     |    67     |
| **小端法** |    67     |    45     |    23     |    01     |

**-字节顺序的意义**

​	1.在不同类型的机器之间通过网络传送二进制数据时：

​		当小端法机器产生的数据被发送到大端法机器或者反之，接收程序就会发现，字例的字节成了反序



### 2.1.5 表示字符串

* C中的字符串被编码为一个以null(其值为0)字符结尾的字符数组
* 每个字符都有某个标准编码来表示，如ASCII字符码
  eg：123456 对应的ASCII值为 31 32 33 34 35 (16进制)
  * 十进制数字x的ASICII码正好是$0x3x$
  * 终止字节的十六进制表示为0x00



### 2.1.6 表示代码

### 2.1.7 布尔代数和环

<img src="C:\Users\麦德安\AppData\Roaming\Typora\typora-user-images\image-20220616215425256.png" alt="image-20220616215425256" style="zoom:67%;" /><img src="C:\Users\麦德安\AppData\Roaming\Typora\typora-user-images\image-20220616215437781.png" alt="image-20220616215437781" style="zoom:67%;" />

<img src="C:\Users\麦德安\AppData\Roaming\Typora\typora-user-images\image-20220616215452146.png" alt="image-20220616215452146" style="zoom:67%;" /><img src="C:\Users\麦德安\AppData\Roaming\Typora\typora-user-images\image-20220616215506091.png" alt="image-20220616215506091" style="zoom:67%;" />

### 2.1.8 C中的位级运算

### 2.1.9 C中的逻辑运算

## 2.2 整数表示

## 2.3 整数运算

## 2.4 浮点数

# **第三章 程序的机器级表示**

# **第四章 处理器体系结构**

# **第五章 优化程序性能**

# **第六章 存储器层次结构**

